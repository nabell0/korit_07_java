# intellij.md 파일에서의 자동 줄바꿈 설정
1. atrl +alt + s 누른다 / command + , 누른다 -> 설정

# 추상 클래스
- abstract - 추상적인
## 추상 클래스의 정의
1. 추상 메서드가 하나라도 포함되면 해당 클래스는 추상 클래스로 정의돼야 함.
2. 추상 클래스는 객체를 생성할 수 없음 -> 일반 클래스와의 차이
3. 그 외의 다른 특징은 일반 클래스와 동일함
4. 상속을 전제로 하는 클래스

- 추상 메서드 (abstract method) - 선언만 있고, 구현은 없는 메서드
- 추상 클래스 (abstract class) - 추상 메서드가 '하나 이상인' 클래스

- 일반 메서드 vs. 추상 메서드 구조 차이({} 영역의 유무)
```java
// 일반 메서드
public void showInfo(){
    System.out.println("제 이름은 "+ name + "입니다.");
}
// 추상 메서드
public abstract showName();
```
## 추상 클래스의 장점
코드의 재사용성을 높이고 설계를 보다 명확하게 할 수 있도록 도와준다.

## 추상 클래스의 목적
1. 공통된 기능 제공  : 여러 클래스에서 공통적으로 사용하는 기능을 추상 클래스에서 정의가능
2. 구체적인 구현 _강제_ : 추상 메서드를 통해 자식 클래스가 '반드시 특정 메서
 드를' 구현하도록 강제할 수 있음.
3. 코드의 재사용성 : 중복되는 코드를 줄이고, 유지보수성을 향상

## 주의 사항
객체 생성 못함.
/*
지시 사항
1. Factory 클래스를 상속 받을 것
2. 그러면 시뻘건거 오류 뜨는데 알아서 처리할 것
3. TabletFactory의 고유 method인 upgrade(String model) 메서드를 call2()
유형으로 정의하고, 객체명.upgrade("아이패드 프로 13인치 8세대");로 호출하면
'아이패드 프로 13인치 8세대로 업그레이드합니다.' 라고 콘솔에 출력될 수 있도록
작성할 것
4. Main.java로 이동해서
tabletFactory1 객체를 생성하고, 애플 태블릿 공장이라고 이름 붙일 것
5. 이름을 구글 태플릿 공장으로 수정할 것 -> getter를 활용
현재 공장은 구글 태블릿 공장으로 변경되었습니다.
라고 출력할 수 있도록 작성할 것.
6. 객체명.produce("구글 태블릿")을 호출할 것
7. 객체명.manage()를 호출할 것
8. 객체명.upgrade("구글 태블릿 10인치 2세대")를 호출할 것
9. Factory 클래스의 인스턴스인 factory2 객체를 생성할 것
- produce() 메서드는 model + 컴퓨터를 생산합니다. 라고 출력될 수 있도록 재정의
- manage() 메서드는 컴퓨터 공장을 관리합니다. 라고 출력될 수 있도록 재정의
factory2 메서드의 name은 삼성 컴퓨터 공장으로 set하시오.
factory2.showInfo()를 호출할 것
*/

# 인터페이스(Interface)
- Java에서 클래스가 구현해야하는 '메서드들'의 집합을 정의하는 일종의 규약
  (protocol)
- 인터페이스는 메서드의 시그니처(메서드명, 리턴 타입, 매개변수 목록)만을 포함
하며, 메서드의 실제 구현은 포함하지 않음 -> 추상메서드만 있음.
- 다중 상속을 지원 -> 이를 통해 클래스가 여러 인터페이스를 구현할 수 있음.
 - 추상 클래스는 단일 상속을 지원해서 상속 과정을 알아보기 쉽다고 작성했는데,
 - 얘는 다중상속을 지원하기 때문에 또 편하다고 이야기를 합니다.
## 특징
1. 추상 메서드 : 인터페이스 내의 모든 메서드들은 기본적으로 추상 메서드
  - 추상 클래스는 일반 메서드도 있었지만, 인터페이스는 강제적으로 추상 메서드
입니다.
2. 상수 : 인터페이스 내에 선언된 변수는 모두 자동으로 'public static
final' 상수로 취급됩니다.
3. 다중 상속 : 클래스는 여러 인터페이스를 구현 (implements)할 수 있음.

## 추상 클래스와의 공통점
- 모두 추상 메서드를 포함할 수 있고, 이를 서브 클래스에서 구현해야만 함.
## 추상 클래스와의 차이점
- 추상 클래스
   1. 부분 구현 허용 : 추상 클래스는 추상 메서드 뿐만 아니라 일반 메서드도 포함할 수 있다.
  2. 상태 저장 가능 : 추상 클래스는 field를 가질 수 있다.
  3. 단일 상속 : (일반) 클래스는 하나의 추상 클래스만 상속받을 수 있다.
  4. 생성자 : 추상 클래스는 생성자를 가질 수 있다.
```java
// 어떤 추상 클래스
public abstract class Person{
    //필드 선언
 private String name;
 
 // AllArgsConstructor
 public Person(String name){
     this.name = name;
 }
 
 //method 구현
 public  abstract introduce();
}

//위의 추상 클래스를 상속받는 일반 클래스
public class Student extends Person{
    // 서브 클래스의 필드 선언
    // Student 클래스가 객체를 생성할 수 있는 경우의 수는 이렇게 두 가지만 존재하게 됩니다.
    private String school;
    public Student(String name){
        super(name);
    }
    public Student(String name , String school){
        super(name);
        this.school=school;
    }
}
```

이상의 코드라인으로 알 수 있는 것은, 객체 생성을 직접적으로 하지 못하는 추상 클래스의 생성자
의 유무로 인해 자식 클래스의 생성자 정의 방식(객체 생성 방식)을 통제할 수 있다는 점.

그래서 특정 서브 클래스의 객체 생성 방식을 강제하고 싶을 때 사용하는 것이 추상 클래스의 생성
자라고 생각하면 됨.

 5. 다양한 접근 지정자 (Access Modifier) : 추상 클래스의 메서드와 변수는 다양한 접근 지정
자를 가질 수 있다.
- 인터페이스
  1. 완전한 추상화 : 인터페이스는 기본적으로 모든 메서드가 추상 메서드(Java8 이후에
    default / static 메서드를 사용가능하긴 합니다.)
  2. 인터페이스는 인스턴스 변수(필드 중 객체마다 값이 다른 변수를 의미함)를 가질 수 없고,
  상수만 선언 가능(final 키워드)
  3. 다중 상속 : 클래스는 여러 인터페이스를 '구현할 수 있다.' (상속과 용어를 구분 짓는 편)
  4. 생성자 없음 : 인터페이스는 생성자를 가질 수 없다.'
      - 일단 필드에서 객체마다 다른 값을 지닐 수 없고 상수만 선언 가능하기 때문에 필드에 값을
     대입하는 생성자 자체를 만들 수 없겠죠.
  5. 자동 public : 인터페이스의 메서드들은 자동으로 public이며, 메서드 선언에 접근 지정자
    를 명시할 필요x (근데 또 Java8 이후에 default / static 메서드가 생긴점이 문제.)
  
# Interface 예시

interface이기 때문에 변수 앞에 접근 지정자를 명시하고 않고,
final 키워드도 적지 않지만

        public final이 생략되어있습니다. 그래서 String 앞에 final을
        명시하더라도 Intellij 상에서 불필요하다는 안내가 나옵니다.
        복습하실 때 String 앞에 한 번 final 붙여보시기 바랍니다.

## 안되는 예시들 나열
//    String age;// field(인스턴스 변수)선언 불가능
//    public Press(){}; // 생성자 불가능
//    void popOut(){
//        System.out.println("추상 메서드 x / 얘는 일반 메서드");
//    }

//되는 예시
```java
void onPressed(); // 무조건 추상메서드로 정의할것.
String onPressed2();// call3() 형태로도 가능 하지만 상속 받을땐 꼭 return 값 생각하기.

```
## Interface 이후
- Interface 이후에는 Interface를 상속받을 클래스를 지정하여 상속하기.
예시) Button 추상화 클래스에 abstranct class Button -> 'implements(구현)' interface명
- 이럴경우 나오는 예시코드
```java
public abstract class Button implements Press,Up,Down{
    @Override
    public void onDown() { // 일반 메서드지만 메서드 본문에 아무것도 안써놓음.

    }

    @Override
    public abstract void onPressed();

    @Override
    public String onUp() {
            return "올립니다.";
    }
}
```
위와 같이 interface의 추상화메서드를 상속하여 Button을 부모 클래스로 지정후에
1. 필요한 자식클래스에 상속할 것.
예시 
```java
public class ChannelUpButton extends Button{
    @Override
    public void onPressed() {
        System.out.println("채널을 한 칸 올립니다.");
    }

    @Override
    public String onUp() {
       return "채널을 계속 "+ super.onUp();
    }
}
```
형식으로 상속한 후에 구현을 위해 생성자 생성
예시
```java
public  class TvRemoteController{
    // 필드 선언 <- 여기서 부턴 내가 생성한 클래스로 필드 선언을 할수 있음.
  private ChannelUpButton channelUpButton;
  
  // 이후 생성자 생성
  public TvRemoteController(ChannelUpButton channelUpButton){
      this.channelUpButton=channelUpButton;
  }
  // 이 이후 Main class에도 생성자 호출
  public static void main(String[] args) {
    // 새로운 생성자 호출 안에 (추상 클래스는 객체생성을 못하기 때문에 생성자를 강제적으로 넣어 객체를 생성하게 함.)
    // 생성자 호출 안에 생성자를 새롭게 호출하는 형식 밑에 처럼.
    TvRemoteController tvRemoteController = new TvRemoteController(new channelUpButton());
    tvRemoteController.onUpChannelUpButton();
  }
  //이 이후 필요한 부분을 호출하기 위해 TvRemoteController 클래스 속에서 선언한 필드의 (객체)를 메서드로 호출하는 방법
  public void onUpChannelUpButton(){
    System.out.println(channelUpButton.onUp());//<<상속한 class에서 call3()유형으로 작성되었기 때문에 return 값을 반환형식.
  }
  //이 이후 다시 Main으로 돌아가 
  //tvRemoteController.onUpChannelUpButton(); // 생성자명.메서드명 을 호출하면 콘솔에 호출.
}
```
