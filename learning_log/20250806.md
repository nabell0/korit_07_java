# cord convention 관련

```java
import java.util.Scanner;

public class PersonMain {
    public static void main(String[] args) {
        // 사용할 외부 및 내부 클래스 목록들 전부 import 해옴
        Scanner scanner = new Scanner(System.in);
        Array08 array08 = new Array08();
        // 사용하는 변수 목록들 전부 선언
        int randomNum;
        double[] scores = new double[25];
        String[] students = new String[25];
        //...
        // 막 내부 로직들 엄청나게 써놓고 있다고 가정하다가
        //저밑에서 갑자기
        // students가 튀어나왔다고 가정.
        if (randomNum<0)
        {
            //이런 방식으로 실행문을 써야 합니다. 라는 식으로 회사에서 정하는 경우가 많음.
        }
    }
}
```
# 상속(Inheritance)
- 객체지향프로그래밍(oop)의 핵심 개념 중 하나로, 기존 클래스 (부모(슈퍼)클래스)의
field와 method를 재사용하여 새로운 클래스(자식(서브)클래스)를 만드는 것을 의미함.

## 상속의 필요성
- 상속을 통해 공통적인 기능을 부모 클래스에 정의하고, 이를 '여러' 자식 클래스가
재사용 가능

    - 동물(Animal) 클래스가 있고, 이를 상속 받는 개(dog)/ 고양이(Cat)클래스가 있다고
      가정했을 때, 동물의 공통적인 field(이름 / 나이 등)와 행위(걷기 / 먹기 등)을
      부모 클래스에 정의, 개와 고양이는 각각 고유한 특성(짖기 / 우다다다)을 추가할 수 있음

- 이상의 과정을 거쳤을 때 얻을 수 있는 이점 : Dog에 이름 / 나이 / 걷기 / 먹기 / 짖기를 정의하고
  또 Cat에다가 이름 / 나이 / 걷기 / 먹기 / 우다다다를 정의하는 등의 공통된 부분을

  정의하는 일 없이 특정 field 및 메서드만 정의하면 됨 . -> 중복된 코드를 줄일 수 있다.

## 상속의 특징
1. 단일 상속
  - Java는 단일 상속만 지원함. 하나의 클래스는 한 번에 하나의 부모 클래스만 상속 받을 수 있어
  상속 구조가 간단하고 명확함.
2. super 키워드
  - 클래스의 생성자 및 setter에서 학습한 this와 유사한 개념으로
  부모 클래스의 field에 접근하거나 부모 클래스의 생성자를 호출할 때 사용함(두 가지 사용법이 있습니다.)
3. _method override_
  - 자식 클래스에서 부모 클래스의 기본 동작을 `재정의`할 수 있음. 이를 통해 자식 클래스는 부모
 클래스의 기본 동작을 자신만의 방식으로 변경 가능
  - 예시
    - Animal 클래스의 걷기를 Dog가 상속 받고, 네 발로 걷기로 _재정의_, Human 클래스가 걷기를
    상속 받고 두발로 걷기로 _재정의_가 가능합니다.
4. final 키워드 - 클래스에 final이 붙으면 상속 불가
    - method에 final이 붙으면 메서드 오버라이딩 불가능

## 장점
1. 코드 재사용성 - 동일한 코드를 반복적으로 작성할 필요 x
2. 유지 보수의 용이성
    - 부모 클래스의 변경 사항이 자식 클래스에 자동으로 반영되기 때문에 위계 파악 후 수정하면 됨.
3. 객체 간 관계 표현 - Is-A 관게를 명확히 나타냄.
    -IS-A
    '개'는 '동물'의 일종이다. 와 같은 예시로, IS-A는 is a kind of의 축약어
    - 그래서 우리가 미리 만들어둔 Animal / Tiger / Human의 클래스를 예로 들었을 때
    - Human / Tiger는 Animal 클래스의 자식(서브) 클래스다.

## super 키워드

1. super();             ->얘는 부모 생성자를 호출한다는 의미
2. super.메서드명();     ->얘는 부모 클래스의 메서드를 호출한다는 의미

    지금 작성하는 부분의 경우 github에 완전판이 올라가기 때문에 왜 오류가 발생하는지
    어떻게 검증하는지 어려움을 겪을 수 있음.

    부모-자식의 상속관계가 성립되어 있을 때.
    부모 클래스에서 기본 생성자 없이 매개변수 생성자만 있다면
    자식 클래스에서 완벽한 기본 생성자를 만드는 것이 불가능.

    자식 클래스의 객체 생성 시 필수적으로 '부모 클래스의 생성자를 호출'하기 때문.

    // 어떤 객체를 생성한다고 가정할때
    A a = new B();
    같은 형태의 객체 생성 방식이 튀어나오게 되는데 (추후 수업 예정)
    이상의 방식은 정보처리기사에서는 단골 문제입니다.